var stores: nodeIndex<String, node<TripleStore>>;

@volatile
type DBRecord {
    subject: String;
    predicate: String;
    object: String;
    parsed: String;
}

@volatile
type ProcessingFileResult {
    nbLines: int;
    nbFiles: int;
    nbError: int;
    totalDuration: duration;
    startTime: time;
    endTime: time;
    static fn new(): ProcessingFileResult {
        return ProcessingFileResult {
            nbLines: 0,
            nbFiles: 0,
            nbError: 0,
            totalDuration: 0_s,
            startTime: time::now(),
            endTime: time::now(),
        };
    }

    fn addFile() {
        this.nbFiles = this.nbFiles + 1;
    }

    fn addLine() {
        this.nbLines = this.nbLines + 1;
    }

    fn addError() {
        this.nbError = this.nbError + 1;
    }

    fn add(other: ProcessingFileResult) {
        this.nbLines = this.nbLines + other.nbLines;
        this.nbFiles = this.nbFiles + other.nbFiles;
        this.nbError = this.nbError + other.nbError;
        if (other.startTime < this.startTime) {
            this.startTime = other.startTime;
        }
        if (other.endTime > this.endTime) {
            this.endTime = other.endTime;
        }
        this.totalDuration = this.endTime - this.startTime;
    }

    fn speed(): float {
        this.endTime = time::now();
        var d = (this.endTime - this.startTime).tof(DurationUnit::seconds);
        if (d <= 0.0) {
            d = 1.0;
        }
        return (this.nbLines * 1.0 / d);
    }

    fn to_string(name: String) {
        var format_speed = float::to_string(this.speed(), '.', ',', 3, false);
        info("Store: ${name} - Parsed ${int::to_string(this.nbFiles, ',')} files, ${int::to_string(this.nbLines, ',')} lines, ${int::to_string(this.nbError, ',')} failed, speed: ${format_speed} lines/s");
    }
}

type TripleStore {
    name: String;
    subjects: nodeIndex<String, node<TSSubject>>;
    predicates: nodeIndex<String, node<TSPredicate>>;
    objects: nodeIndex<String, node<TSObject>>;

    static fn getOrCreateStore(name: String): node<TripleStore> {
        var res = stores.get(name);
        if (res == null) {
            res = node<TripleStore> {
                TripleStore {
                    name: name,
                    subjects: nodeIndex<String, node<TSSubject>> {},
                    predicates: nodeIndex<String, node<TSPredicate>> {},
                    objects: nodeIndex<String, node<TSObject>> {},
                }
            };
            stores.set(name, res);
        }
        return res;
    }

    fn add(subject: String, predicate: String, object: String, value: any?) {
        //Get or create Subject:
        var nSubject = this.subjects.get(subject);
        if (nSubject == null) {
            nSubject = node<TSSubject> {
                TSSubject {
                    name: subject,
                    predicates: nodeIndex<node<TSPredicate>, nodeIndex<node<TSObject>, node<Triplet>>> {}
                }
            };
            this.subjects.set(subject, nSubject);
        }
        //Get or create Predicate:
        var nPredicate = this.predicates.get(predicate);
        if (nPredicate == null) {
            nPredicate = node<TSPredicate> {
                TSPredicate {
                    name: predicate,
                    subjects: nodeIndex<node<TSSubject>, nodeIndex<node<TSObject>, node<Triplet>>> {}
                }
            };
            this.predicates.set(predicate, nPredicate);
        }
        //Get or create Object:
        var nObject = this.objects.get(object);
        if (nObject == null) {
            nObject = node<TSObject> {
                TSObject {
                    name: object,
                    predicates: nodeIndex<node<TSPredicate>, nodeIndex<node<TSSubject>, node<Triplet>>> {}
                }
            };
            this.objects.set(object, nObject);
        }

        //Insert relation in Subject:
        var nsi = nSubject->predicates.get(nPredicate);
        if (nsi == null) {
            nsi = nodeIndex<node<TSObject>, node<Triplet>> {};
            nSubject->predicates.set(nPredicate, nsi);
        }

        //Insert relation in Predicate:
        var npi = nPredicate->subjects.get(nSubject);
        if (npi == null) {
            npi = nodeIndex<node<TSObject>, node<Triplet>> {};
            nPredicate->subjects.set(nSubject, npi);
        }

        //Insert relation in Object:
        var noi = nObject->predicates.get(nPredicate);
        if (noi == null) {
            noi = nodeIndex<node<TSSubject>, node<Triplet>> {};
            nObject->predicates.set(nPredicate, noi);
        }

        var nTriplet = nsi.get(nObject);
        if (nTriplet == null) {
            nTriplet = node<Triplet> {
                Triplet {
                    subject: nSubject,
                    predicate: nPredicate,
                    object: nObject,
                    value: value
                }
            };
            nsi.set(nObject, nTriplet);
            npi.set(nObject, nTriplet);
            noi.set(nSubject, nTriplet);
        } else {
            //TODO, strategy when relation already exists, either ignore, or replace by newer, or merge
            //error("Relation already exists");
        }
    }
}

type TSSubject {
    name: String;
    predicates: nodeIndex<node<TSPredicate>, nodeIndex<node<TSObject>, node<Triplet>>>;
}

type TSPredicate {
    name: String;
    subjects: nodeIndex<node<TSSubject>, nodeIndex<node<TSObject>, node<Triplet>>>;
}

type TSObject {
    name: String;
    predicates: nodeIndex<node<TSPredicate>, nodeIndex<node<TSSubject>, node<Triplet>>>;
}

type Triplet {
    subject: node<TSSubject>;
    predicate: node<TSPredicate>;
    object: node<TSObject>;
    value: any?;
}

abstract type TripleStoreService {
    static fn importFile(path: String, nStore: node<TripleStore>): ProcessingFileResult {
        var csvReader = CsvReader<DBRecord> {
            path: path,
            format: CsvFormat { header_lines: 0, separator: ' ', string_delimiter: '\"' }
        };
        var result = ProcessingFileResult::new();
        result.addFile();
        while (csvReader.can_read()) {
            try {
                var record = csvReader.read();
                nStore->add(record.subject, record.predicate, record.object, null);
            } catch (ex) {
                error("Failed file: ${path}, line: ${csvReader.last_line()}, exception: ${ex}");
                result.addError();
            }
            result.addLine();
        }
        result.endTime = time::now();
        result.to_string(nStore->name);
        return result;
    }

    static fn importDir(path: String) {
        var jobs = Array<Job> {};
        for (i, f in File::ls(path, null, true)) {
            var name = f.name();
            var nStore = TripleStore::getOrCreateStore(name);
            jobs.add(Job { function: TripleStoreService::importFile, arguments: [f.path, nStore] });
        }
        await(jobs, MergeStrategy::strict);
        var result = ProcessingFileResult::new();
        for (i, j in jobs) {
            result.add(j.result() as ProcessingFileResult);
        }
        result.to_string("ALL");
        info("Done Loading everything");
    }
}

